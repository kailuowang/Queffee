{"name":"Queffee","tagline":"A small dynamic priority work queue library in Coffeescript. ","body":"queffee.js is a small library and for the most part it has two public classes: queffee.Q - a dynamic priority job queue and queffee.Worker - well, a worker. You can enqueue tasks (asynchronous functions) into the queue and start a worker, then the worker will run those functions one by one. You can also start multiple workers can they will work on multiple tasks in parallel (in a single thread).\r\n\r\n### Incentive\r\nAs an example ajax web application, let's look at a picture slide show running in a browser.\r\nLet's start with the basic usage. In the slide show, there are many picture objects, which have a preload function that preloads the picture content to the browser so that when user select to display them, they will be immediately ready. This preload function is asynchronous and takes in a callback to call when the preload is done.:\r\n\r\n```\r\n  class Picture\r\n    preload: (callback) =>\r\n      #preloading itself in browser, callback on success\r\n```\r\nYou can always simply do\r\n```\r\n  for pic in pictures\r\n    picture.preload()\r\n```\r\nThe issue here is that because preload is asynchronous, this will run all of them simultaneously, so if you have too many pictures, that might be simply too many requests to the server. You can better manage that using queffee.\r\n\r\n### Basic Usage\r\n```\r\n    q = new queffee.Q\r\n    worker = new queffee.Worker(q)\r\n    for pic in pictures\r\n      q.enQ picture.preload\r\n```\r\n\r\nThe worker will preload picture one after another, so one request at a time. If you want more simultaneous connections you can always start more workers.\r\n\r\n```\r\n  anotherWorker = new queffee.Worker(q)\r\n  #or\r\n  _(4).times -> new queffee.Worker(q)\r\n```\r\n\r\n### Dynamic Priority\r\nNow let's look at a more advanced use case. In a slide show, users might select to skip some pictures and jump to a picture further down in slide. So preloading the pictures they already skipped is probably not as important as preloading the pictures immediately after the one they are seeing now. So we need to prioritize the preloading according to the current progress of the user. queffee supports that. When you enQ, you can give it a priority function and it will be used for the priority queue. Let's say you added a priority function to your picture class\r\n\r\n```\r\n  class Picture\r\n    priority: =>\r\n      #calculates its priority according to the distance to the current progress\r\n```\r\n\r\nthen you can enQ the preloads like the following\r\n\r\n```\r\n   q.enQ picture.preload, picture.priority\r\n```\r\n\r\nNow when users skip pictures, you just need to call\r\n\r\n```\r\n   q.reorder()\r\n```\r\n\r\nThen the preloading works will be re-prioritized according to the new slideshow progress.\r\nIf you don't need to dynamically prioritize the tasks, you can also pass in a number value as the priority.\r\n\r\n### Add Offline Support to Your Front End \r\nSo far so good right? Another really interesting usage of queffee is to support offline mode for you ajax application. \r\nBack to the picture slide show as the example. With enough preloaded pictures, it should be able to work fine after the browser goes offline. However, like most other ajax web apps, even with the data available locally, it still needs to update state back to server. Specifically in this app, if user operated on the picture, it needs to update the server with the latest states. More specifically, it needs to send ajax put/post requests back to the server. We don't really need a response from the server but if the browser goes offline, such ajax requests will be lost. With queffee, the problem can be elegantly solved with the following code.\r\n\r\n```\r\n  class Updater\r\n    constructor: ->\r\n      @_q = new queffee.Q\r\n      @_worker = new queffee.Worker(@_q)\r\n\r\n    put: (url, data) => this._addJob('put', url, data)\r\n\r\n    post: (url, data) => this._addJob('post', url, data)\r\n\r\n    _addJob: (method, url, data) =>\r\n      @_q.enQ (callback) =>\r\n        $.ajax(\r\n                url: url\r\n                data: data\r\n                type: type\r\n                success: callback\r\n                error: => setTimeout(@_worker.retry, 180000)\r\n              )\r\n```\r\n\r\nThen just use this updater to do the ajax update\r\n\r\n```\r\n  class Picture\r\n    update: => updater.put('/picture', this)\r\n```\r\n\r\nThat's it. The picture.update() methods is offline safe now. The Updater class uses queffee to run the ajax requests one by one. If disconnection causes one ajax request to fail, it will automatically retry every 3 minutes until it succeeds and continue with the following one. The way it detects the disconnection is a bit naive here but you got the idea. \r\nThere are two not so obvious things here: 1) the worker will not proceed to the next job until the current job finishes and calls callback, so if the ajax call in the current job fails, the worker will stay with the current job 2) the worker.retry() function re-run current job again which if succeeds, will start moving things again. \r\n\r\n### Working with promise\r\nYou can also queue work using a parameterless function that returns a promise, queffee will run it and wait for promise to resolve.\r\n    \r\n```\r\n  doSomethingAsync = ->\r\n    ...\r\n    promise\r\n  \r\n  q = new queffee.Q\r\n  q.enQ(doSomethingAsync)\r\n  #or\r\n  job = new queffee.Job(doSomethingAsync, priority: 0, timeout: 2000)\r\n  q.enqueue(job)\r\n```\r\n\r\n\r\n### Working with synchronous functions\r\nYou can also queue work using a synchronized parameterless function, queffee will run it asynchronously.\r\n    \r\n```\r\n  doSomething = ->\r\n    #...some time consuming synchronous process\r\n  \r\n  q = new queffee.Q\r\n  q.enQ(doSomething)\r\n  #or\r\n  job = new queffee.Job(doSomething, priority: 0, timeout: 2000)\r\n  q.enqueue(job)\r\n```\r\nThis way you can also use queffee to manage a set of time consuming synchronous tasks, parallelize them (by using multiple workers), prioritize them and so on.\r\n\r\n\r\n### Tweaking queffee\r\nBy default queffee.Worker waits on the asynchronous task indefinitely, but if you give it a ms timeout (value or function), it will move on the next task after timeout.\r\nFor example, the following code waits at most 10 seconds for the picture to finish reload, after which the next picture will get preloaded.\r\n\r\n```\r\n   q.enQ picture.preload, picture.priority, 10000\r\n```\r\n\r\n### Some Utils  \r\nIn some cases you have a collection of asynchronous tasks and you want to run all of them sequentially and meanwhile monitor the progress. I wrote a util class in queffee called CollectionWorkQ just for that.\r\nHere is the usage, let's still take the preloading pictures as the example, except this time we don't care about the priority but we need to monitor the progress.\r\n\r\n```\r\n    new queffee.CollectionWorkQ(\r\n      collection: pictures\r\n      operation: 'preload'\r\n      onProgress: -> alert('another picture ready!')\r\n      onFinish: -> alert('finished')\r\n    ).start()\r\n```\r\n\r\nThis should be intuitive enough, the operation option takes in a function name that will be called on each item of the collection. The operation option can also be a function that takes in an item and a callback like the following\r\n\r\n```\r\n    new queffee.CollectionWorkQ(\r\n      collection: pictures\r\n      operation: (picture, callback) -> picture.preload(callback)\r\n    ).start()\r\n```\r\n\r\n### Real Life Performance \r\nThe core data structure of queffee is an array based binary heap as the queue. queffee has been tested as part of a real web application on machines with low process power such as the original Chromebook and Android tablets. The application ran smoothly with thousands of work tasks and reordering of the whole queue a couple of times every second.  \r\n\r\n### To do TDD\r\nBased on the change to module management in [`npm` v1.0+](http://blog.nodejs.org/2011/03/23/npm-1-0-global-vs-local-installation/ \"npm 1.0: Global vs Local installation &laquo; node blog\"), the following modules are now local to this project:\r\n\r\n* [coffee-script](https://github.com/jashkenas/coffee-script)\r\n* [uglify-js](https://github.com/mishoo/UglifyJS)\r\n* [growl](https://github.com/visionmedia/node-growl), which requires [growlnotify](http://growl.info/extras.php#growlnotify \"Growl - Extras\") to be available on your `PATH`\r\n\r\nYou shouldn't have to install them with `npm`.  If you're not running OS X, or don't have Growl available, you obviously won't see any pretty notifications.  But it should be trivial to replace that function with your OS specific variant if you'd like to.\r\nFrom project root:\r\n```\r\n$  cake watch:development\r\n```\r\nand open SpecRunner.html in browser\r\n\r\n### To build js and min js\r\n```\r\n$  cake build\r\n```\r\n\r\n### Acknowledgment\r\n* used skeleton project [InstantJasmineCoffee](https://github.com/krismolendyke/InstantJasmineCoffee \"InstantJasmineCoffee\")\r\n\r\n\r\n### License\r\n\r\nCopyright (c) 2011 Kailuo Wang\r\n\r\nPermission is hereby granted, free of charge, to any person\r\nobtaining a copy of this software and associated documentation\r\nfiles (the \"Software\"), to deal in the Software without\r\nrestriction, including without limitation the rights to use,\r\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the\r\nSoftware is furnished to do so, subject to the following\r\nconditions:\r\n\r\nThe above copyright notice and this permission notice shall be\r\nincluded in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\r\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\r\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\r\nOTHER DEALINGS IN THE SOFTWARE.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}